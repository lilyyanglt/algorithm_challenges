# [Best Time to Buy and Sell Stock II](https://leetcode.com/problems/best-time-to-buy-and-sell-stock-ii/)

**Goal:** 
- Given array of nums `prices` for the ith element is the price of a given stock on day i.
- Design an algorithm to find max profit. You may complete as many transactions as you like (ie. Buy one and sell share of the stock multiple times). You must sell stock before you buy again)

**Input:**
1. [7, 2, 5, 6, 1]
1. [1, 7, 8, 2, 3, 5]
1. [1, 2, 3, 4, 5, 6]
1. [3]
1. [1, 1, 1, 1, 1]
1. [7, 5, 4, 3, 2, 1]

**Output:**
1. return 4, because buy at 2, sell at 5 that's 3, buy at 5 sell at 6 that's 1, therefore 3 + 1 = 4
1. return 10, because buy at 1, sell at 7, that's 6, buy at 7, sell at 8, that's 1, buy at 2, sell at 3, that's 1, buy at 3, sell at 5, that's 2 - 6 + 1 + 1 + 2 = 10
1. return 5 
1. return 0
1. return 0
1. return 0

**Constraints**
1 <= prices.length <= 3 * 10 ^ 4
0 <= prices[i] <= 10 ^ 4

## Possible Questions to ask Interviewer when given this question

Input: 
- I don't quite understand the note about being able to complete as many transactions as I like. Does this mean, that I can buy stock when it's at price say 1, and then sell it again and again? 
Answer: So no, it just means that say [1, 2, 1, 5, 6, 7] say these are your data and price of stock at day i, you can choose to buy on day i = 0, which is the lowest value, and then sell it say day i = 1, so profit is 1, then you can buy again the next day, so this is what it means to complete as many transaction as you like.

Output:
n/a

## Test Scenario

- Start planning the test cases - think about all the edge cases first and make sure your algorithm is designed in a way to handle all the edge cases

1. test when there's only 1 day of stock price - should return 0, since there's no day to sell
1. test when all stock values are the same - should return 0, since no profit will be earned
1. test when stock values decreases day by day - should return 0
1. test when stock values increases day by day - should return correct max profit
1. test when stock values are random up and down - should return correct max profit

## Pseudocode

1. n <- prices.size(), max_prof <- 0
1. for i < - 0 to n - 2
   - d <- prices[i + 1] - prices[i]
     - if d > 0, max_prof <- max_prof + d

smallest subproblem is: d = nums[i+1] - nums[i]

## Outcome

1. Attempt 1 - Succeeded
* Time Complexity - O(n)
* Space Complexity - O(1)
* time spent on solving this problem: 30 minutes

```cpp

// author: lily yang

class Solution {
public:
    int maxProfit(vector<int>& prices) {
        int n = prices.size(), max_profit = 0, difference = 0;
        
        if (n == 1) return 0;
        
        for (int i=0;i<n-1;i++) {
            if (prices[i+1] > prices[i]) {
                difference = prices[i+1] - prices[i];
                max_profit += difference;
            }
        }
        
        return max_profit;
    }
};

```

## Other submission learnings and Solution Review

## Retro
